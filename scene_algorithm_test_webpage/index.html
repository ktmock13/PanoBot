<!DOCTYPE html>
<html>
<head>
  <style>
    .canvas {
      color: red;
    }
    .desired {
      color: blue;
    }
    .actual {
      color:green;
    }
  </style>
</head>
<body>
  <p class="canvas">canvas 360x360 (projected sphere)</p>
  <div>
    <label for="cameraSelect">Camera Presets:</label>
    <select id="cameraSelect">
      <option value="IPHONE_5X_PORT">iPhone 5x Port</option>
      <option value="IPHONE_3X_LAND">iPhone 2x Land</option>
      <option value="IPHONE_2X_PORT">iPhone 2x Port</option>
      <option value="IPHONE_1X_LAND">iPhone 1x Land</option>
    </select>
    <br>
    <label class="desired" for="rangeX">Desired X FOV:</label>
    <input type="number" id="rangeX" name="rangeX" value="60">
    <br>

    <label class="desired"  for="rangeY">Desired Y FOV:</label>
    <input type="number" id="rangeY" name="rangeY" value="30">
    <br>

    <label for="overlapPercent">Overlap Percent:</label>
    <input type="number" step="0.01" id="overlapPercent" name="overlapPercent" value="0.2">
    <br>

    <button onclick="createAndPrintScene()">Run Simulation</button>
    <br><br>

  </div>

  <div id="finalFOV">
    <p class="actual">Note: the scene algorthm will get as close to desired size as possible without undershooting. This means the final photo will always be slightly larger. Below is the *actual* FOV, shown in green. </p>
    <span class="actual" id="finalFOVX">Final FOV X: </span><br>
    <span class="actual" id="finalFOVY">Final FOV Y: </span>
  </div>
  <canvas id="shotCanvas1" height="3600" width="3600"></canvas>

  <script type="text/javascript">

    const ZOOM = 10; // each pixel is represented as 1 degree, this zoom multiplier does just that
    class Shot {
      constructor(x, y, height, width) {
        this.x = x;
        this.y = y;
        this.height = height;
        this.width = width;
      }
      getFillRectValue() {
        return [this.x, this.y, this.height, this.width]
      }
      getDisplayTexts() {
        return [`x:${this.x}`, `y:${this.y}`, `h:${this.height}`, `w:${this.width}\n`]
      }
    }

    class Camera {
      constructor(fovDegrees, aspectRatio) {
        this.fovDegrees = fovDegrees; // assumed to be widest dimension of rectangle
        this.aspectRatio = aspectRatio;
        this.isLandscape = aspectRatio >= 1
        //calculate shotHeight and shotWidth based on fov and aspect
      }
      getHorizontalFov() {
        // if this is a landscape photo, the this.fovDegrees value is the horizontal fov
        return this.isLandscape ? this.fovDegrees : this.fovDegrees * this.aspectRatio;
      }
      getVerticalFov() {
        // if this is a portrait photo, the this.fovDegrees value is the vertical fov
        return !this.isLandscape ? this.fovDegrees : this.fovDegrees * (1 / this.aspectRatio);
      }
    }

    class Scene {
      constructor(camera, rangeX, rangeY, overlapPercent = 0.333, shotCanvasId = "shotCanvas1") {
        this.camera = camera;
        this.rangeX = rangeX; // total FOV degrees desired, ex. 100
        this.rangeY = rangeY; // total FOV degrees desired, ex. 50
        this.shotSequence = [] // will be computed below
        /** @type {CanvasRenderingContext2D} */
        this.canvas = document.getElementById(shotCanvasId).getContext("2d")

        // set canvas dimensions
        this.canvas.width = 360 * ZOOM;
        this.canvas.height = 360 * ZOOM;

        const xOverlapPercent = overlapPercent; // this logic should change
        const yOverlapPercent = overlapPercent; // this logic should change

        // FOV units between shots, considering overlap
        const xSpacing = (this.camera.getHorizontalFov() * (1 - xOverlapPercent))
        const ySpacing = (this.camera.getVerticalFov() * (1 - yOverlapPercent))

        // Amount of FOV units that the shots overlap
        const xOverlapAmount = (this.camera.getHorizontalFov() - xSpacing);
        const yOverlapAmount = (this.camera.getVerticalFov() - ySpacing);

        // Min # of photos in each dimension to cover the desired range
        let sceneDimensionX = Math.ceil((rangeX - xOverlapAmount) / xSpacing);
        let sceneDimensionY = Math.ceil((rangeY - yOverlapAmount) / ySpacing);

        // Calculate final FOV ranges
        this.finalFOVRangeX = sceneDimensionX * xSpacing + xOverlapAmount;
        this.finalFOVRangeY = sceneDimensionY * ySpacing + yOverlapAmount;

        // Log the final FOV ranges
        console.log(`Actual X FOV: ${this.finalFOVRangeX}`);
        console.log(`Actual Y FOV: ${this.finalFOVRangeY}`);

        // All shots will be calculated from this frame of reference
        const firstShot = new Shot(0, 0, this.camera.getHorizontalFov(), this.camera.getVerticalFov())
        // Helper function to move to make new shots relative to a shot
        const moveShot = (shot, xDistance, yDistance) => new Shot(shot.x + xDistance, shot.y + yDistance, shot.height, shot.width)
        for (let iy = 0; iy < sceneDimensionY; iy++) {
          if(iy%2===0){
            for (let ix = 0; ix < sceneDimensionX; ix++) {
              // compute each shot
              this.shotSequence.push(moveShot(firstShot, ix * xSpacing, iy * ySpacing))
            }}
            else {
              for (let ix = sceneDimensionX-1; ix >= 0; ix--) {
                // compute each shot
                this.shotSequence.push(moveShot(firstShot, ix * xSpacing, iy * ySpacing))
              }
            }
         
        }
      }
      printShotText(shot) {

        this.canvas.fillStyle = "black";
        const fontSize = 10;
        this.canvas.font = `${fontSize}px sans-serif`;
        function round(num) {
          return Math.floor(num * 100) / 100
        }
        const dimensionsText = `x:${round(shot.x)} y:${round(shot.y)}`
        const cameraCode = 'ðŸ“¸';
        this.canvas.fillText(cameraCode, (shot.x + (shot.height / 2)) * ZOOM, (shot.y + (shot.width / 2)) * ZOOM)
      }
      printShot(shot) {
        this.canvas.fillStyle = "rgb(255 0 150 / 10%)";
        this.canvas.fillRect(...shot.getFillRectValue().map(val => val * ZOOM));
      }
      printShots(shots) {
        if (shots.length) {
          shots.forEach(shot => {
            this.printShot(shot)
          })
        }
      }
      printScene(scene) {
        if (scene.shotSequence.length) {
          scene.shotSequence.forEach(shot => {
            this.printShot(shot)
          })
        }
      }
      async slowlyPrintScene(scene, delay) {
        function timeout(ms) {
          return new Promise(resolve => setTimeout(resolve, ms))
        }
        if (scene.shotSequence.length) {
          for (let shot of scene.shotSequence) {
            this.printShot(shot)
            await timeout(delay / 2)
            this.printShotText(shot)
            await timeout(delay / 2)
          }
        }
      }
      printCanvasBounds() {
        // Set the border color
        this.canvas.strokeStyle = "red";
        // Set the border thickness
        this.canvas.lineWidth = 3;
        this.canvas.strokeRect(0, 0, 360 * ZOOM, 360 * ZOOM)
      }
      printSceneBounds() {
        // Set the border color
        this.canvas.strokeStyle = "blue";
        // Set the border thickness
        this.canvas.lineWidth = 1;
        this.canvas.strokeRect(0, 0, this.rangeX * ZOOM, this.rangeY * ZOOM)
        this.canvas.strokeStyle = "green";
        this.canvas.strokeRect(0, 0, this.finalFOVRangeX * ZOOM, this.finalFOVRangeY * ZOOM)
        
      }
    }

    /* Display Helper */
    function printScenesWithBoundaries(scenes) {
      scenes.forEach((scene, i) => {
        scene.printCanvasBounds();
        scene.printSceneBounds();
        scene.slowlyPrintScene(scene, 100);
      })
    }

    // Define the cameras outside of any function to make them globally accessible
    const IPHONE_5X_PORT = new Camera(11.3, .75);
    const IPHONE_3X_LAND = new Camera(22.8, 1.33);
    const IPHONE_2X_PORT = new Camera(37.5, .75);
    const IPHONE_1X_SQUARE = new Camera(75, 1);
    const IPHONE_WIDE_LAND = new Camera(130, 1);
    function clearCanvas() {
      const canvas = document.getElementById('shotCanvas1');
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
    }
    function createAndPrintScene() {
      clearCanvas(); // Clear the canvas before drawing a new scene

      const cameraSelect = document.getElementById('cameraSelect').value;
      let camera;
      switch (cameraSelect) {
        case 'IPHONE_5X_PORT':
          camera = IPHONE_5X_PORT;
          break;
        case 'IPHONE_3X_LAND':
          camera = IPHONE_3X_LAND;
          break;
        case 'IPHONE_2X_PORT':
          camera = IPHONE_2X_PORT;
          break;
        case 'IPHONE_1X_LAND':
          camera = IPHONE_1X_LAND;
          break;
        case 'IPHONE_WIDE_LAND':
          camera = IPHONE_WIDE_LAND;
          break;
      }
      
      const rangeX = parseInt(document.getElementById('rangeX').value);
      const rangeY = parseInt(document.getElementById('rangeY').value);
      const overlapPercent = parseFloat(document.getElementById('overlapPercent').value);
      
      const scene = new Scene(camera, rangeX, rangeY, overlapPercent, "shotCanvas1");
      // Update Final FOV display
      document.getElementById('finalFOVX').textContent = `Actual X FOV: ${scene.finalFOVRangeX}`;
      document.getElementById('finalFOVY').textContent = `Actual Y FOV: ${scene.finalFOVRangeY}`;

      printScenesWithBoundaries([scene]);
    }

    // Set default values and load the scene on page load
    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('cameraSelect').value = 'IPHONE_5X_PORT';
      createAndPrintScene(); // Automatically run the scene with default values on page load
    });

  </script>
</body>

</html>